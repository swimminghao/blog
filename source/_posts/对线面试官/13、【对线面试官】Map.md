---
title: 13、【对线面试官】Map
tags:
  - 面试
  - 记录
categories: 技术
abbrlink: f78aff48
date: 2022-02-28 19:57:47
---
# 13、【对线面试官】Map

## 今天来讲讲Map吧，你对Map了解多少？就讲JDK1.8就好咯

- Map在Java里边是一个接口，常见的实现类有HashMap、 LinkedHashMap、TreeMap和ConcurrentHashMap

1. 在Java里边，哈希表的实现由数组+链表所组成
2. HashMap底层数据结构是数组+链表/红黑树
3. LinkedHashMap底层数据结构是数组+链表+双向链表
4. TreeMap底层数据结构是红黑树
5. 而ConcurrentHashMap底层数据结构也是数组+链表/红黑树

## 我们先以HashMap开始吧，你能讲讲当你new一个HashMap的时候，会发生什么吗？

1. 如果我们不指定，默认HashMap的大小为16，负载因子的大小为0.75
2. 还有就是：HashMap的大小只能是2次幂的，假设你传一个10进去，实际上最终HashMap的大小是16，你传一个7进去，HashMap最终的大小是8，具体的实现在tableSizeFor可以看到。
3. 我们把元素放进HashMap的时候，需要算出这个元素所在的位置（hash）
4. 在HashMap里用的是位运算来代替取模，能够更加高效地算出该元素所在的位置
5. 为什么HashMap的大小只能是2次幂，因为只有大小为2次幂时，才能合理用位运算替代取模。
6. 而负载因子的大小决定着哈希表的扩容和哈希冲突。
7. 比如现在我默认的HashMap大小为16，负载因子为0.75，这意味着数组最多只能放12个元素，一旦超过12个元素，则哈希表需要扩容
8. 怎么算出是12呢？很简单，就是16*0.7 5。每次put元素进去的时候，都会检查HashMap的大小有没有超过这个阈值，如果有，则需要扩容。
9. 鉴于上面的说法（HashMap的大小只能是2次幂），所以扩容的时候时候默认是扩原来的2倍
10. 还有就是扩容这个操作肯定是耗时的，那能不能把负载因子调高一点，比如我要调至为1，那我的HashMap就等到16个元素的时候才扩容呢。
11. 当然是可以的，但是不推荐。负载因子调高了，这意味着哈希冲突的概率会增高，哈希冲突概率增高，同样会耗时（因为查找的速度变慢了）

## 算了。我还想继续问下，在put元素的时候，传递的Key是怎么算哈希值的？

1. 实现就在hash方法上，可以发现的是，它是先算出正常的哈希值，然后与高16位做异或运算，产生最终的哈希值。
2. 这样做的好处可以增加了随机性，减少了碰撞冲突的可能性。

## 你简单再说下put和get方法的实现吧

1. 在put的时候，首先对key做hash运算，计算出该key所在的index。
2. 如果没碰撞，直接放到数组中，如果碰撞了，需要判断目前数据结构是链表还是红黑树，根据不同的情况来进行插入。
3. 假设key是相同的，则替换到原来的值。最后判断哈希表是否满了（当前哈希表大小*负载因子），如果满了，则扩容
4. 在get的时候，还是对key做hash运算，计算出该key所在的index，然后判断是否有hash冲突
5. 假设没有冲突直接返回，假设有冲突则判断当前数据结构是链表还是红黑树，分别从不同的数据结构中取出。

## 那在HashMap中是怎么判断一个元素是否相同的呢？

1. 首先会比较hash值，随后会用==运算符和equals（）来判断该元素是否相同。
2. 说白了就是：如果只有hash值相同，那说明该元素哈希冲突了，如果hash值和equals（）|| ==都相同，那说明该元素是同个。

## 你说HashMap的数据结构是数组+链表/红黑树，那什么情况拿下才会用到红黑树呢？

1. 当数组的大小大于64且链表的大小大于8的时候才会将链表改为红黑树，当红黑树大小为6时，会退化为链表。
2. 这里转红黑树退化为链表的操作主要出于查询和插入时对性能的考量。
3. 链表查询时间复杂度O（N），插入时间复杂度O（1），红黑树查询和插入时间复杂度O（logN）

## 你在日常开始中LinkedHashMap用的多吗？

1. 在前面也提到了，LinkedHashMap底层结构是数组+链表+双向链表，实际上它继承了HashMap，在HashMap的基础上维护了一个双向链表
2. 有了这个双向链表，我们的插入可以是有序的，这里的有序不是指大小有序而是插入有序
3. LinkedHashMap在遍历的时候实际用的是双向链表来遍历的，所以LinkedHashMap的大小不会影响到遍历的性能

## 那TreeMap呢？

1. TreeMap在现实开发中用得也不多，Tre eMap的底层数据结构是红黑树
2. TreeMap的key不能为null（如果为null，那还怎么排序呢），TreeMap有序是通过Comparator来进行比较的，如果comparator为null，那么就使用自然顺序

## 再来讲讲线程安全的Map吧？ HashMap是线程安全的吗？

1. HashMap不是线程安全的，在多线程环境下，HashMap有可能会有数据丢失和获取不了最新数据的问题，比如说：线程Aput进去了，线程Bget不出来。
2. 想要线程安全，一般使用ConcurrentHashMap
3. ConcurrentHashMap是线程安全的Map 实现类，它在juc包下的。
4. 线程安全的Map实现类除了ConcurrentHashMap还有一个叫做Hashtable。
5. 当然了，也可以使用Collections来包装出一个线程安全的Map。
6. 但无论是Hashtable还是Collections包装出来的都比较低效（因为是直接在外层套synchronize），所以我们一般有线程安全问题考量的，都使用ConcurrentHashMap
7. ConcurrentHashMap的底层数据结构是数组+链表/红黑树，它能支持高并发的访问和更新，是线程安全的。
8. ConcurrentHashMap通过在部分加锁和利用CAS算法来实现同步，在get的时候没有加锁，Node都用了volatile给修饰。
9. 在扩容时，会给每个线程分配对应的区间，并且为了防止putVal导致数据不一致，会给线程的所负责的区间加锁

## 嗯，你可以给我讲讲JDK7和JDK8中HashMap和ConcurrentHashMap的区别吗？

1. 我在学习的时候也看过JDK7的HashMap和ConcurrentHashMap，其实还是有很多不一样的地方
2. 比如JDK7的HashMap在扩容时是头插法，在JDK8就变成了尾插法，在JDK7的HashMap还没有引入红黑树
3. ConcurrentHashMap在JDK7还是使用分段锁的方式来实现，而JDK8就又不一样了。但JDK7细节我大多数都忘了。
4. 我就没用过JDK7的API，我想着现在最低应该也是用JDK8了吧？所以我就没去仔细看了。