---
title: 6、【对线面试官】CAS
tags:
  - 面试
  - 记录
categories: 技术
abbrlink: 759e745e
date: 2022-02-28 19:57:47
---
# 6、【对线面试官】CAS

## 今天我们来聊聊CAS吧？你对CAS了解多少？

1. CAS的全称为compare and swap，比较并交换
2. 虽然翻译过来是「比较并交换」，但它是一个原子性的操作，对应到CPU指令为cmpxchg
3. cpu指令你都知道？->这没什么，都是背的。
4. 回到CAS上吧，CAS的操作其实非常简单。
5. CAS有三个操作数：当前值A、内存值V、要修改的新值B
6. 假设当前值A跟内存值V相等，那就将内存值V改成B
7. 假设当前值A跟内存值V不相等，要么就重试，要么就放弃更新
8. 将当前值与内存值进行对比，判断是否有被修改过，这就是CAS的核心

## 确实，那为什么要用CAS呢？

1. 嗯，要讲到CAS就不得不说synchronized锁了，它是Java锁..然后..
2. ok，其实就是synchronized锁每次只会让一个线程去操作共享资源
3. 而CAS相当于没有加锁，多个线程都可以直接操作共享资源，在实际去修改的时候才去判断能否修改成功
4. 在很多的情况下会synchronized锁要高效很多
5. 比如，对一个值进行累加，就没必要使用synchronized锁，使用juc包下的Atomic类就足以。 

## 了解，那你知道CAS会有什么缺点吗？

1. CAS有个缺点就是会带来ABA的问题
2. 从CAS更新的时候，我们可以发现它只比对当前值和内存值是否相等，这会带来个问题，下面我举例说明下：
3. 假设线程A读到当前值是10，可能线程B把值修改为100，然后线程C又把值修改为10。
4. 等到线程A拿到执行权时，因为当前值和内存值是一致的，线程A是可以修改的！
5. 站在线程A的角度来说，这个值是从未被修改的（：
6. 这是不合理的，因为我们从上帝的角度来看，这个变量已经被线程B和线程C修改过了。
7. 这就是所谓的ABA问题
8. 要解决ABA的问题，Java也提供了AtomicStampedReference类供我们用，说白了就是加了个版本，比对的就是内存值+版本是否一致

## 阿里巴巴开发手册提及到推荐使用LongAdder对象，比AtomicLong性能更好（减少乐观锁的重试次数）

1. AtomicLong做累加的时候实际上就是多个线程操作同一个目标资源
2. 在高并发时，只有一个线程是执行成功的，其他的线程都会失败，不断自旋（重试），自旋会成为瓶颈
3. 而LongAdder的思想就是把要操作的目标资源「分散」到数组Cell中
4. 每个线程对自己的Cell变量的value进行原子操作，大大降低了失败的次数
5. 这就是为什么在高并发场景下，推荐使用LongAdder的原因
